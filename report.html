<!DOCTYPE html><html><head>
      <title>report</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:////users/eleves-a/2021/erik.dziekonski-bautista/.vscode-server/extensions/shd101wyy.markdown-preview-enhanced-0.8.13/crossnote/dependencies/katex/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h3 id="introduction">Introduction </h3>
<p>In this assignment, we implemented a raytracer project to render 3D scenes with various features such as diffuse and mirror surfaces, direct lighting and shadows, indirect lighting, antialiasing, and ray-mesh intersection with Bounding Volume Hierarchy (BVH) acceleration. The main objective was to create a realistic and visually appealing rendering of the scene by simulating the interaction of light with different surfaces and materials.</p>
<p>The implemented features include:</p>
<ol>
<li>Diffuse and mirror surfaces</li>
<li>Direct lighting and shadows for point light sources</li>
<li>Indirect lighting for point light sources (without Russian roulette)</li>
<li>Antialiasing</li>
<li>Ray-mesh intersection with BVH acceleration</li>
</ol>
<p><strong>ALL of the images below except the cat have the following config:</strong></p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code>    <span class="token keyword keyword-int">int</span> imageWidth <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> imageHeight <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
    Vector camera <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> fieldOfView <span class="token operator">=</span> <span class="token function">degToRad</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> maxDepth <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> raysPerPixel <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>
</code></pre><h3 id="diffuse-and-mirror-surfaces">Diffuse and Mirror Surfaces </h3>
<p>To simulate diffuse and mirror surfaces, we implemented the Phong reflection model. For diffuse surfaces, the incoming light is scattered equally in all directions, resulting in a matte appearance. The diffuse color of the surface is calculated based on the angle between the surface normal and the direction of the incoming light.</p>
<p>For mirror surfaces, the incoming light is reflected in a single direction, creating a specular highlight. The reflected ray direction is calculated using the law of reflection, which states that the angle of incidence equals the angle of reflection.<br>
<img src="./images/diffuse+mirror_16734ms_.png" alt="mirror"><br>
<em>This image took 16734ms to render</em></p>
<p>The code snippet below shows how the diffuse and mirror surfaces are handled in the <code>getColor</code> function:</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>intersection<span class="token punctuation">.</span>isReflective<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Ray reflectedRay <span class="token operator">=</span> <span class="token function">Ray</span><span class="token punctuation">(</span>localPosition<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token function">dot</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> localNormal<span class="token punctuation">)</span> <span class="token operator">*</span> localNormal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">getColor</span><span class="token punctuation">(</span>reflectedRay<span class="token punctuation">,</span> depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Add direct lighting in diffuse case</span>
<span class="token keyword keyword-double">double</span> distance <span class="token operator">=</span> <span class="token punctuation">(</span>lightSource <span class="token operator">-</span> localPosition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Vector lightDirection <span class="token operator">=</span> <span class="token punctuation">(</span>lightSource <span class="token operator">-</span> localPosition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Intersection lightIntersection <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>lightSource<span class="token punctuation">,</span> lightDirection <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> visibility <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>lightIntersection<span class="token punctuation">.</span>intersects <span class="token operator">||</span> lightIntersection<span class="token punctuation">.</span>distance <span class="token operator">&gt;</span> distance<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1.</span> <span class="token operator">:</span> <span class="token number">0.</span><span class="token punctuation">;</span>
color <span class="token operator">=</span> lightIntensity <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> M_PI <span class="token operator">*</span> distance <span class="token operator">*</span> distance<span class="token punctuation">)</span> <span class="token operator">*</span> intersection<span class="token punctuation">.</span>color <span class="token operator">/</span> M_PI <span class="token operator">*</span> visibility <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">,</span> localNormal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>In the code above, if the surface is reflective (mirror), a reflected ray is generated and recursively traced to calculate the color. For diffuse surfaces, the direct lighting contribution is calculated based on the light intensity, surface color, and the angle between the light direction and the surface normal.</p>
<h3 id="direct-lighting-and-shadows">Direct Lighting and Shadows </h3>
<p>To implement direct lighting and shadows for point light sources, we calculate the visibility of the light source from the intersection point. We shoot a ray from the intersection point towards the light source and check if there are any occluding objects between them. If there are no occluders, the intersection point is illuminated by the light source, and the direct lighting contribution is added to the pixel color.</p>
<p>The direct lighting contribution is calculated using the following formula:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>color = lightIntensity / (4 * PI * distance^2) * surfaceColor / PI * visibility * max(0, dot(lightDirection, surfaceNormal))
</code></pre><p>Here, <code>lightIntensity</code> is the intensity of the point light source, <code>distance</code> is the distance between the intersection point and the light source, <code>surfaceColor</code> is the color of the surface, <code>visibility</code> is either 1 (illuminated) or 0 (shadowed), and <code>dot(lightDirection, surfaceNormal)</code> represents the cosine of the angle between the light direction and the surface normal.</p>
<p><img src="./images/shadow_dir_lig_16635ms.png" alt="shadow_dir"><br>
<em>This image took 16635ms to render</em></p>
<p>The code snippet below shows how direct lighting and shadows are implemented in the <code>getColor</code> function:</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-double">double</span> distance <span class="token operator">=</span> <span class="token punctuation">(</span>lightSource <span class="token operator">-</span> localPosition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Vector lightDirection <span class="token operator">=</span> <span class="token punctuation">(</span>lightSource <span class="token operator">-</span> localPosition<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Intersection lightIntersection <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>lightSource<span class="token punctuation">,</span> lightDirection <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> visibility <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span>lightIntersection<span class="token punctuation">.</span>intersects <span class="token operator">||</span> lightIntersection<span class="token punctuation">.</span>distance <span class="token operator">&gt;</span> distance<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1.</span> <span class="token operator">:</span> <span class="token number">0.</span><span class="token punctuation">;</span>
color <span class="token operator">=</span> lightIntensity <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> M_PI <span class="token operator">*</span> distance <span class="token operator">*</span> distance<span class="token punctuation">)</span> <span class="token operator">*</span> intersection<span class="token punctuation">.</span>color <span class="token operator">/</span> M_PI <span class="token operator">*</span> visibility <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">,</span> localNormal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="indirect-lighting">Indirect Lighting </h3>
<p>Indirect lighting simulates the bouncing of light between surfaces, resulting in a more realistic and globally illuminated scene. In this implementation, indirect lighting is achieved by shooting random rays from the intersection point and recursively tracing them to gather the incoming light from other surfaces.</p>
<p>The indirect lighting contribution is calculated by multiplying the surface color with the color obtained from the recursively traced random ray. This process is repeated for a fixed number of bounces (determined by the <code>depth</code> parameter) to capture the multiple bounces of light.</p>
<p>This is a ball <em>without</em> indirect lighting:<br>
<img src="./images/no_indir_2866ms.png" alt="without_indir"><br>
<em>This image took 2866ms to render</em></p>
<p>And this is <strong>with</strong> indirect lighting:<br>
<img src="./images/ind_light_64851.png" alt="with_indir"><br>
<em>This image took 64851ms to render</em></p>
<p>The code snippet below shows how indirect lighting is implemented in the <code>getColor</code> function:</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token comment">// Indirect lighting</span>
Ray randomRay <span class="token operator">=</span> <span class="token function">Ray</span><span class="token punctuation">(</span>localPosition<span class="token punctuation">,</span> <span class="token function">randomCosineDirection</span><span class="token punctuation">(</span>localNormal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
color <span class="token operator">=</span> color <span class="token operator">+</span> intersection<span class="token punctuation">.</span>color <span class="token operator">*</span> <span class="token function">getColor</span><span class="token punctuation">(</span>randomRay<span class="token punctuation">,</span> depth <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>In the code above, a random ray is generated using the <code>randomCosineDirection</code> function, which returns a random direction based on the cosine-weighted distribution around the surface normal. The color obtained from tracing the random ray is multiplied with the surface color and added to the pixel color.</p>
<h3 id="antialiasing">Antialiasing </h3>
<p>Antialiasing is a technique used to reduce the appearance of jagged edges (aliasing) in rendered images. In this implementation, antialiasing is achieved through supersampling, where multiple rays are shot per pixel and their colors are averaged to obtain the final pixel color.</p>
<p>The supersampling process is performed by generating random offsets for each ray within the pixel's area. These offsets are generated using the Box-Muller transform, which produces random numbers with a Gaussian distribution.</p>
<p>No antialiasing:<br>
<img src="./images/no_anti_61ms.png" alt="no_anti"><br>
<em>This image took 61ms to render</em></p>
<p>With antialising:<br>
<img src="./images/yes_anti_27711ms.png" alt="yes_anti"><br>
<em>This image took 27711ms to render</em></p>
<p>The code snippet below shows how antialiasing is implemented in the main rendering loop:</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> raysPerPixel<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">BoxMuller</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> offsetX<span class="token punctuation">,</span> offsetY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vector pixel <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span>camera<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> offsetX<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">-</span> imageWidth <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
                          camera<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>y <span class="token operator">+</span> offsetY<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0.5</span> <span class="token operator">+</span> imageHeight <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span>
                          camera<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> imageWidth <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token function">tan</span><span class="token punctuation">(</span>fieldOfView <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Ray ray <span class="token operator">=</span> <span class="token function">Ray</span><span class="token punctuation">(</span>camera<span class="token punctuation">,</span> <span class="token punctuation">(</span>pixel <span class="token operator">-</span> camera<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pixelColor <span class="token operator">=</span> pixelColor <span class="token operator">+</span> scene<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span> maxDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
pixelColor <span class="token operator">=</span> pixelColor <span class="token operator">/</span> raysPerPixel<span class="token punctuation">;</span>
</code></pre><p>In the code above, <code>raysPerPixel</code> determines the number of rays to be shot per pixel. For each ray, random offsets (<code>offsetX</code> and <code>offsetY</code>) are generated using the Box-Muller transform. The pixel position is adjusted based on these offsets, and a ray is generated from the camera to the pixel. The colors of all the rays are accumulated and averaged to obtain the final pixel color.</p>
<h3 id="ray-mesh-intersection-and-bvh">Ray Mesh Intersection and BVH </h3>
<p>To render meshes in the raytracer, we implemented the Möller–Trumbore ray-triangle intersection algorithm. This algorithm efficiently determines whether a ray intersects a triangle by solving a system of linear equations. The algorithm calculates the barycentric coordinates of the intersection point within the triangle and checks if they are within the valid range (between 0 and 1).</p>
<p>The Möller–Trumbore algorithm is implemented in the <code>intersect</code> function of the <code>TriangleMesh</code> class. The code snippet below shows the key steps of the algorithm:</p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code><span class="token keyword keyword-double">double</span> beta <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>vertexA <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">,</span> edge2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">dot</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> gamma <span class="token operator">=</span> <span class="token operator">-</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>vertexA <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">,</span> edge1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">dot</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> alpha <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> beta <span class="token operator">-</span> gamma<span class="token punctuation">;</span>
<span class="token keyword keyword-double">double</span> t <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>vertexA <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">,</span> normal<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">dot</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>alpha <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> beta <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gamma <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">&lt;</span> tMin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tMin <span class="token operator">=</span> t<span class="token punctuation">;</span>
    intersection<span class="token punctuation">.</span>intersects <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    intersection<span class="token punctuation">.</span>distance <span class="token operator">=</span> t<span class="token punctuation">;</span>
    intersection<span class="token punctuation">.</span>position <span class="token operator">=</span> vertexA <span class="token operator">+</span> beta <span class="token operator">*</span> edge1 <span class="token operator">+</span> gamma <span class="token operator">*</span> edge2<span class="token punctuation">;</span>
    intersection<span class="token punctuation">.</span>normal <span class="token operator">=</span> normal<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>To accelerate the rendering process when dealing with large meshes, we implemented a Bounding Volume Hierarchy (BVH). The BVH is a tree-like structure that hierarchically subdivides the mesh into smaller bounding volumes. Each leaf node of the BVH contains a subset of the mesh triangles, while internal nodes represent the bounding volumes of their child nodes.</p>
<p>The BVH is constructed by recursively splitting the mesh triangles based on their spatial distribution. In our implementation, we choose the splitting plane along the longest axis of the bounding box and partition the triangles based on their centroid position relative to the splitting plane.</p>
<p>During the intersection process, the BVH is traversed from the root node. If a ray intersects the bounding volume of a node, its child nodes are recursively checked for intersection. This hierarchical approach allows us to quickly discard large portions of the mesh that are not intersected by the ray, significantly reducing the number of ray-triangle intersection tests.</p>
<p><img src="./images/bvh_cat_111199ms.png" alt="cat_bvh"><br>
<em>This image took 111199ms to render with the following config:</em></p>
<pre data-role="codeBlock" data-info="cpp" class="language-cpp cpp"><code>    <span class="token keyword keyword-int">int</span> imageWidth <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> imageHeight <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span>
    Vector camera <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> fieldOfView <span class="token operator">=</span> <span class="token function">degToRad</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-double">double</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> maxDepth <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-int">int</span> raysPerPixel <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
</code></pre><p>The BVH implementation provided a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo><mn>7</mn><mo>×</mo></mrow><annotation encoding="application/x-tex">\sim7\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mord">×</span></span></span></span> in rendering times compared to testing the ray against every triangle in the mesh.</p>
<h3 id="additional-features-optional">Additional Features (Optional) </h3>
<p>In addition to the basic features, we implemented the following optional features in our raytracer:</p>
<ol>
<li>
<p>Transparent Surfaces:<br>
We added support for transparent surfaces by implementing refraction based on Snell's law and Fresnel equations. When a ray intersects a transparent surface, it is split into a reflected ray and a refracted ray. The Fresnel equations determine the amount of light that is reflected and refracted at the surface interface. This allows us to render objects with varying degrees of transparency and create realistic glass-like materials.</p>
<p><img src="./images/transparent_22388ms.png" alt="transparent"><br>
<em>This image took 22388ms to render</em></p>
</li>
</ol>
<h3 id="conclusion">Conclusion </h3>
<p>In this assignment, we successfully implemented a raytracer with various features to render 3D scenes with realistic lighting and shading. The key features included diffuse and mirror surfaces, direct lighting and shadows, indirect lighting, antialiasing, and ray-mesh intersection with BVH acceleration.</p>
<p>The implementation of diffuse and mirror surfaces allowed us to simulate different material properties and create visually diverse scenes. Direct lighting and shadows added a sense of depth and realism to the rendered images. Indirect lighting, although computationally expensive, provided a more natural and globally illuminated look to the scenes.</p>
<p>Antialiasing, achieved through supersampling, significantly improved the visual quality of the rendered images by reducing jagged edges and aliasing artifacts. The Möller–Trumbore algorithm enabled efficient ray-triangle intersection tests, while the BVH acceleration structure greatly improved the rendering performance for scenes with complex meshes.</p>
<p>During the implementation process, we encountered challenges such as ensuring the correctness of the intersection calculations, handling numerical precision issues, and optimizing the performance of the raytracer. However, by carefully debugging and optimizing the code, we were able to overcome these challenges and achieve satisfactory results.</p>
<p>In the future, there are several potential improvements and extensions that can be made to the raytracer. These include implementing more advanced shading models, such as physically-based rendering (PBR), adding support for volumetric effects like fog and participating media, and exploring more efficient acceleration structures like the k-d tree or the bounding interval hierarchy (BIH).</p>
<p>Overall, this assignment provided hands-on experience in implementing a raytracer from scratch and understanding the fundamental concepts and algorithms involved in realistic image synthesis. The implemented features contributed to the creation of visually appealing and physically plausible rendered images.</p>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>